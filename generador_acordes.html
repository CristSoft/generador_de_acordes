<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Generador de Acordes</title>
  <!-- Bootstrap 5 CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    body {
      transition: background-color 0.3s, color 0.3s;
    }

    .dark-mode {
      background-color: #343a40;
      color: #f8f9fa;
    }

    .light-mode {
      background-color: #f8f9fa;
      color: #212529;
    }

    header {
      padding: 20px;
      position: relative;
    }

    .dark-mode header {
      background-color: #212529 !important;
      color: #f8f9fa !important;
    }

    .light-mode header {
      background-color: #0d6efd !important;
      color: #fff !important;
    }

    .container {
      max-width: 600px;
      margin-top: 20px;
      margin-bottom: 60px;
    }

    .dark-mode .svg-box {
      border: 1px solid #212529;
      background: #212529;
      padding: 10px;
      margin-top: 20px;
      overflow-x: auto;
    }

    .light-mode .svg-box {
      border: 1px solid #dee2e6;
      background: #ffffff;
      padding: 10px;
      margin-top: 20px;
      overflow-x: auto;
    }

    .floating-download {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1050;
      display: none;
      width: 60px;
      height: 60px;
      border-radius: 50%;
    }

    #themeToggle {
      position: fixed;
      top: 10px;
      right: 10px;
      background: transparent;
      border: none;
      color: inherit;
      font-size: 24px;
      cursor: pointer;
      z-index: 1100;
    }

    body.light-mode #themeToggle .material-icons {
      color: #212529;
    }

    body.dark-mode .btn-generate {
      background-color: #212529;
      border-color: #212529;
      color: #f8f9fa;
    }

    body.light-mode .btn-generate {
      background-color: #0d6efd;
      border-color: #0d6efd;
      color: #fff;
    }

    .btn-generate:hover {
      opacity: 0.9;
    }

    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      text-align: center;
      padding: 5px 0;
      font-size: 0.7rem;
      border-top: 1px solid;
      transition: background-color 0.3s, color 0.3s, border-color 0.3s;
    }

    body.light-mode .footer {
      background-color: #f8f9fa;
      color: #6c757d;
      border-color: #dee2e6;
    }

    body.dark-mode .footer {
      background-color: #212529;
      color: #adb5bd;
      border-color: #343a40;
    }

    /* Botón “▷” junto al SVG */
    .play-btn {
      display: inline-block;
      margin-left: 8px;
      cursor: pointer;
      font-size: 20px;
      vertical-align: middle;
      color: #0d6efd;
    }

    .play-btn:hover {
      color: #084298;
    }
  </style>
</head>

<body class="dark-mode">
  <header>
    <h1 class="text-center">Generador de Acordes</h1>
  </header>
  <button id="themeToggle" onclick="toggleTheme()">
    <span class="material-icons">light_mode</span>
  </button>
  <div class="container">
    <div class="mb-3">
      <label for="instrumentSelect" class="form-label">Selecciona Instrumento:</label>
      <select class="form-select" id="instrumentSelect">
        <option value="piano" selected>Piano</option>
        <option value="guitar">Guitarra</option>
      </select>
    </div>
    <div class="mb-3">
      <label for="chordInput" class="form-label">
        Ingresa uno o varios acordes (separados por comas o saltos de línea, ej.: C, Dm, G7, A/D, 6/9, 9/2):
      </label>
      <textarea class="form-control" id="chordInput" rows="2" placeholder="C, Dm, G7, A/D, 6/9, 9/2, ..."></textarea>
    </div>
    <div class="mb-3 d-flex justify-content-around">
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="switchNotes" checked onchange="toggleNoteNames()">
        <label class="form-check-label" for="switchNotes">Ver Notas</label>
      </div>
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="switchOctave" checked onchange="toggleOctaveNumbers()">
        <label class="form-check-label" for="switchOctave">Ver Octavas</label>
      </div>
      <div class="form-check form-switch">
        <input class="form-check-input" type="checkbox" id="switchChord" checked onchange="toggleChordName()">
        <label class="form-check-label" for="switchChord">Nombre de Acorde</label>
      </div>
    </div>
    <!-- Opciones de colores para piano -->
    <div class="mb-3">
      <div class="row">
        <div class="col">
          <label for="whiteKeyColorPicker" class="form-label">Color de blancas</label>
          <input type="color" id="whiteKeyColorPicker" value="#ffffff">
          <label for="whiteAlpha" class="form-label" style="font-size: 0.9rem;">Transparencia (0-100%)</label>
          <input type="range" id="whiteAlpha" min="0" max="100" value="100">
        </div>
        <div class="col">
          <label for="blackKeyColorPicker" class="form-label">Color de negras</label>
          <input type="color" id="blackKeyColorPicker" value="#000224">
          <label for="blackAlpha" class="form-label" style="font-size: 0.9rem;">Transparencia (0-100%)</label>
          <input type="range" id="blackAlpha" min="0" max="100" value="100">
        </div>
        <div class="col">
          <label for="highlightColorPicker" class="form-label">Color destacado</label>
          <input type="color" id="highlightColorPicker" value="#c0a5e4">
          <label for="highlightAlpha" class="form-label" style="font-size: 0.9rem;">Transparencia (0-100%)</label>
          <input type="range" id="highlightAlpha" min="0" max="100" value="100">
        </div>
      </div>
    </div>
    <div id="guitarOptions" class="mb-3" style="display:none;">
      <div class="row">
        <div class="col">
          <label for="guitarWidth" class="form-label">Ancho del acorde (px):</label>
          <input type="number" id="guitarWidth" class="form-control" value="130">
        </div>
        <div class="col">
          <label for="guitarHeight" class="form-label">Alto del acorde (px):</label>
          <input type="number" id="guitarHeight" class="form-control" value="250">
        </div>
      </div>
    </div>

    <div class="d-grid gap-2">
      <button class="btn btn-generate btn-lg rounded-pill" onclick="generateChords()">Generar</button>
    </div>
    <div id="svgContainer" class="svg-box"></div>
  </div>
  <button class="btn btn-danger floating-download" id="downloadBtn" onclick="downloadAll()">
    <span class="material-icons">cloud_download</span>
  </button>
  <footer class="footer">
    <p>&copy; 2025 Cristsoft. Todos los derechos reservados.</p>
  </footer>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <!-- Incluir el JS externo para acordes de guitarra, si lo vas a usar -->
  <!-- <script src="chord.js"></script> -->
  <!-- PONÉ ESTO EN TU HTML, justo ANTES de tu <script> que llama a generateChords() -->

    <script>
      // ================================================
      // GenerateGuitarChordSVG (ahora con números de cuerda 6 y 1)
      // ================================================
      function GenerateGuitarChordSVG(name, positions, fingers, size, layout, stringNames, guitarColor1, guitarColor2, guitarColor3, customWidth, customHeight, showFingerNumbers) {
        if (typeof showFingerNumbers === 'undefined') showFingerNumbers = false;        
        let width = parseInt(customWidth) || 150;
        let height = parseInt(customHeight) || 250;
        const svgNS = "http://www.w3.org/2000/svg";
        let svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        svg.style.display = "block";
        svg.style.margin = "0 auto";
      
        // Fondo
        let bgRect = document.createElementNS(svgNS, "rect");
        bgRect.setAttribute("x", "0");
        bgRect.setAttribute("y", "0");
        bgRect.setAttribute("width", width);
        bgRect.setAttribute("height", height);
        bgRect.setAttribute("fill", guitarColor1);
        svg.appendChild(bgRect);
      
        // Márgenes para nombre y diagrama
        let chordNameMargin = 25;
        let marginY = chordNameMargin + 40;
        let marginX = 15;
        let numStrings = 6;
        let numFrets = 5;
        let spacingX = (width - 2 * marginX) / (numStrings - 1);
        let spacingY = (height - marginY - 40) / numFrets; // aumento 20px para espacio abajo de cuerdas
      
        // Calcular baseFret
        let minFret = Infinity, maxFret = 0;
        for (let i = 0; i < positions.length; i++) {
          let p = positions[i].toLowerCase();
          if (p !== "x" && p !== "-" && p !== "0") {
            let fret = parseInt(p);
            if (fret < minFret) minFret = fret;
            if (fret > maxFret) maxFret = fret;
          }
        }
        let baseFret = (maxFret <= 5) ? 1 : minFret;
      
        // Dibujar cuerdas (líneas verticales)
        let stringXs = [];
        for (let i = 0; i < numStrings; i++) {
          let x = marginX + i * spacingX;
          stringXs.push(x);
          let line = document.createElementNS(svgNS, "line");
          line.setAttribute("x1", x);
          line.setAttribute("y1", marginY);
          line.setAttribute("x2", x);
          line.setAttribute("y2", marginY + numFrets * spacingY);
          line.setAttribute("stroke", guitarColor2);
          line.setAttribute("stroke-width", "2");
          svg.appendChild(line);
        }
      
        // Dibujar trastes (líneas horizontales)
        for (let i = 0; i <= numFrets; i++) {
          let y = marginY + i * spacingY;
          let line = document.createElementNS(svgNS, "line");
          line.setAttribute("x1", marginX);
          line.setAttribute("y1", y);
          line.setAttribute("x2", width - marginX);
          line.setAttribute("y2", y);
          line.setAttribute("stroke", guitarColor2);
          line.setAttribute("stroke-width", (i === 0 && baseFret === 1) ? "6" : "2");
          svg.appendChild(line);
        }
      
        // Funciones internas para dibujar círculos y barras
        function drawCircle(x, y, finger) {
          let g = document.createElementNS(svgNS, "g");
          g.setAttribute("data-toggle", "dot");
          let circle = document.createElementNS(svgNS, "circle");
          circle.setAttribute("cx", x);
          circle.setAttribute("cy", y);
          circle.setAttribute("r", "10");
          circle.setAttribute("fill", guitarColor3);
          circle.setAttribute("stroke", guitarColor2);
          circle.setAttribute("stroke-width", "1");
          g.appendChild(circle);
          if (showFingerNumbers && finger && finger !== "-" && finger.toUpperCase() !== "X") {
            let text = document.createElementNS(svgNS, "text");
            text.setAttribute("x", x);
            text.setAttribute("y", y + 4);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("fill", guitarColor2);
            text.setAttribute("font-size", "12");
            text.textContent = finger;
            g.appendChild(text);
          }
          svg.appendChild(g);
        }
      
        function drawBarre(fretIndex) {
          let actualFret = baseFret + fretIndex - 1;
          let y = marginY + (fretIndex - 0.5) * spacingY;
          let startX = stringXs[0] - 10;
          let endX = stringXs[stringXs.length - 1] + 10;
          let barreWidth = endX - startX;
          let g = document.createElementNS(svgNS, "g");
          g.setAttribute("data-toggle", "barre");
          g.setAttribute("data-fret", actualFret);
          let rect = document.createElementNS(svgNS, "rect");
          rect.setAttribute("x", startX);
          rect.setAttribute("y", y - 10);
          rect.setAttribute("width", barreWidth);
          rect.setAttribute("height", "20");
          rect.setAttribute("rx", "10");
          rect.setAttribute("fill", guitarColor3);
          rect.setAttribute("stroke", guitarColor2);
          rect.setAttribute("stroke-width", "1");
          g.appendChild(rect);
          if (maxFret > 5) {
            let fretLabel = document.createElementNS(svgNS, "text");
            let labelX = endX + 5;
            if (labelX > width - marginX) { labelX = width - marginX; }
            fretLabel.setAttribute("x", labelX);
            fretLabel.setAttribute("y", y + 4);
            fretLabel.setAttribute("text-anchor", "start");
            fretLabel.setAttribute("fill", guitarColor2);
            fretLabel.setAttribute("font-size", "12");
            fretLabel.textContent = baseFret;
            g.appendChild(fretLabel);
          }
          svg.appendChild(g);
        }
      
        // Agrupar cejillas
        let barreGroups = {};
        let drawnBarreIndices = new Set();
        for (let i = 0; i < positions.length; i++) {
          let p = positions[i].toLowerCase();
          if (p === "x" || p === "-" || p === "0") continue;
          let fret = parseInt(p);
          let finger = fingers && fingers.length > i ? fingers[i] : "";
          let key = finger + '_' + fret;
          if (!barreGroups[key]) barreGroups[key] = [];
          barreGroups[key].push(i);
        }
        for (let key in barreGroups) {
          let group = barreGroups[key];
          if (group.length >= 2) {
            group.sort((a, b) => a - b);
            let parts = key.split('_');
            let fret = parseInt(parts[1]);
            let adjustedFret = fret - baseFret + 1;
            let cy = marginY + (adjustedFret - 0.5) * spacingY;
            let startIndex = group[0];
            let endIndex = group[group.length - 1];
            let startX = marginX + startIndex * spacingX - 10;
            let endX = marginX + endIndex * spacingX + 10;
            let barreWidth = endX - startX;
            let g = document.createElementNS(svgNS, "g");
            g.setAttribute("data-toggle", "barre");
            let rect = document.createElementNS(svgNS, "rect");
            rect.setAttribute("x", startX);
            rect.setAttribute("y", cy - 10);
            rect.setAttribute("width", barreWidth);
            rect.setAttribute("height", "20");
            rect.setAttribute("rx", "10");
            rect.setAttribute("fill", guitarColor3);
            rect.setAttribute("stroke", guitarColor2);
            rect.setAttribute("stroke-width", "1");
            g.appendChild(rect);
            if (showFingerNumbers && parts[0] && parts[0] !== "-" && parts[0].toUpperCase() !== "X") {
              let text = document.createElementNS(svgNS, "text");
              text.setAttribute("x", startX + barreWidth / 2);
              text.setAttribute("y", cy + 4);
              text.setAttribute("text-anchor", "middle");
              text.setAttribute("fill", guitarColor2);
              text.setAttribute("font-size", "12");
              text.textContent = parts[0];
              g.appendChild(text);
            }
            if (maxFret > 5) {
              let fretLabel = document.createElementNS(svgNS, "text");
              let labelX = endX + 5;
              if (labelX > width - marginX) { labelX = width - marginX; }
              fretLabel.setAttribute("x", labelX);
              fretLabel.setAttribute("y", cy + 4);
              fretLabel.setAttribute("text-anchor", "start");
              fretLabel.setAttribute("fill", guitarColor2);
              fretLabel.setAttribute("font-size", "12");
              fretLabel.textContent = baseFret;
              g.appendChild(fretLabel);
            }
            svg.appendChild(g);
            group.forEach(idx => drawnBarreIndices.add(idx));
          }
        }
      
        // Dibujar puntos individuales
        for (let i = 0; i < positions.length; i++) {
          let p = positions[i].toLowerCase();
          if (p === "x" || p === "-" || p === "0") continue;
          if (drawnBarreIndices.has(i)) continue;
          let fret = parseInt(p);
          let adjustedFret = fret - baseFret + 1;
          let cy = marginY + (adjustedFret - 0.5) * spacingY;
          let cx = marginX + i * spacingX;
          let finger = fingers && fingers.length > i ? fingers[i] : "";
          drawCircle(cx, cy, finger);
        }
      
        // “X” u “O” arriba de cuerdas
        for (let i = 0; i < positions.length; i++) {
          let p = positions[i];
          let x = marginX + i * spacingX;
          if (p.toLowerCase() === "x" || p === "-") {
            let text = document.createElementNS(svgNS, "text");
            text.setAttribute("x", x);
            text.setAttribute("y", marginY - 10);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("fill", guitarColor2);
            text.setAttribute("font-size", "14");
            text.textContent = "X";
            svg.appendChild(text);
          } else if (p === "0") {
            let text = document.createElementNS(svgNS, "text");
            text.setAttribute("x", x);
            text.setAttribute("y", marginY - 10);
            text.setAttribute("text-anchor", "middle");
            text.setAttribute("fill", guitarColor2);
            text.setAttribute("font-size", "14");
            text.textContent = "O";
            svg.appendChild(text);
          }
        }
      
        // Nombre del acorde arriba
        if (document.getElementById("switchChord")?.checked) {
          let nameText = document.createElementNS(svgNS, "text");
          nameText.setAttribute("x", width / 2);
          nameText.setAttribute("y", chordNameMargin);
          nameText.setAttribute("text-anchor", "middle");
          nameText.setAttribute("fill", guitarColor2);
          nameText.setAttribute("font-size", "18");
          nameText.textContent = name;
          svg.appendChild(nameText);
        }
      
        // Agregar número de cuerda 6 (izquierda) y 1 (derecha) abajo del diagrama
        let yLabel = marginY + numFrets * spacingY + 20; // 20px bajo últimas líneas
        // cuerda 6:
        let label6 = document.createElementNS(svgNS, "text");
        label6.setAttribute("x", stringXs[0]);
        label6.setAttribute("y", yLabel);
        label6.setAttribute("text-anchor", "middle");
        label6.setAttribute("fill", guitarColor2);
        label6.setAttribute("font-size", "14");
        label6.textContent = "6";
        svg.appendChild(label6);
        // cuerda 1:
        let label1 = document.createElementNS(svgNS, "text");
        label1.setAttribute("x", stringXs[5]);
        label1.setAttribute("y", yLabel);
        label1.setAttribute("text-anchor", "middle");
        label1.setAttribute("fill", guitarColor2);
        label1.setAttribute("font-size", "14");
        label1.textContent = "1";
        svg.appendChild(label1);
      
        return svg;
      }
      </script>
      
   
  <script>
    // ---------- VARIABLES GLOBALES ----------
    let showOctaveNumbers = true,
      showNoteNames = true,
      showChordName = true;
    const midiData = {}; // { "C": [440, 523.25, ...], ... }

    // Frecuencias base de cuerdas de guitarra (E2, A2, D3, G3, B3, E4)
    const stringFreqs = [82.41, 110, 146.83, 196, 246.94, 329.63];
    // Mapa nota→semitono
    const noteToSemitone = {
      "C": 0,
      "C#": 1,
      "Db": 1,
      "D": 2,
      "D#": 3,
      "Eb": 3,
      "E": 4,
      "F": 5,
      "F#": 6,
      "Gb": 6,
      "G": 7,
      "G#": 8,
      "Ab": 8,
      "A": 9,
      "A#": 10,
      "Bb": 10,
      "B": 11
    };
    const semitoneNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const chordFormulas = {
      "": [0, 4, 7],
      "m": [0, 3, 7],
      "dim": [0, 3, 6],
      "aug": [0, 4, 8],
      "maj7": [0, 4, 7, 11],
      "7": [0, 4, 7, 10],
      "m7": [0, 3, 7, 10],
      "m7b5": [0, 3, 6, 10],
      "ø": [0, 3, 6, 10],
      "dim7": [0, 3, 6, 9],
      "6": [0, 4, 7, 9],
      "sus4": [0, 5, 7],
      "7sus4": [0, 5, 7, 10],
      "5": [0, 7],
      "sus2": [0, 2, 7],
      "add9": [0, 4, 7, 14],
      "m9": [0, 3, 7, 10, 14],
      "maj9": [0, 4, 7, 11, 14],
      "6/9": [0, 2, 4, 7, 9],
      "11": [0, 4, 7, 10, 14, 17],
      "13": [0, 4, 7, 10, 14, 21],
      "9": [0, 2, 4, 7],
      "m6": [0, 3, 7, 9],
      "m11": [0, 3, 7, 10, 14, 17],
      "m13": [0, 3, 7, 10, 14, 21],
      "maj11": [0, 4, 7, 11, 14, 17],
      "maj13": [0, 4, 7, 11, 14, 21],
      "sus9": [0, 2, 5, 7]
    };

    // ---------- EVENTOS INICIALES ----------
    document.getElementById("instrumentSelect").addEventListener("change", function () {
      const instrument = this.value;
      document.getElementById("guitarOptions").style.display = (instrument === "guitar") ? "block" : "none";
    });

    document.getElementById('chordInput').addEventListener('change', function () {
      let chords = this.value.split(/[\n,]+/);
      let formattedChords = chords.map(ch => {
        ch = ch.trim();
        if (!ch) return "";
        return ch.charAt(0).toUpperCase() + ch.slice(1);
      }).filter(Boolean);
      this.value = formattedChords.join(", ");
    });

    // ---------- GENERAR ACORDES Y BOTONES PLAY ----------
    function generateChords() {
      const raw = document.getElementById("chordInput").value;
      let octaveMultiplier = 2; // 2 = una octava arriba, 0.5 = una octava abajo, etc.
      if (!raw.trim()) {
        alert("Ingresá al menos un acorde");
        return;
      }

      const chordsInput = raw.split(/[\n,]+/)
        .map(c => c.trim())
        .filter(Boolean)
        .map(c => c.charAt(0).toUpperCase() + c.slice(1));

      const instr = document.getElementById("instrumentSelect").value;
      const container = document.getElementById("svgContainer");
      container.innerHTML = "";
      // Limpiar datos MIDI anteriores
      for (let key in midiData) delete midiData[key];

      // ---------- PIANO ----------
      if (instr === "piano") {
        chordsInput.forEach(ch => {
          const data = parseChordBinary(ch);
          if (!data) return;
          // 1) generar SVG
          let svg = generateKeyboardSVG(data);
          const chordKey = safeFileName(ch);
          svg = svg.replace("<svg ", `<svg data-chord-name="${chordKey}" `);
          // 2) armar secuencia MIDI de frecuencias (una por una, octava 4)
          const seq = data.chordNotes.map(noteObj => {
            return noteObjToFreq(noteObj.note, noteObj.octave);
          });
          midiData[chordKey] = seq;
          // 3) armar HTML: SVG + botón play
          container.innerHTML += `
            ${svg}
            <span class="play-btn" onclick="playSequence('${chordKey}')">▷</span>
            <br><br>
          `;
        });
        updateDownloadButton();
      }
      // ---------- GUITARRA ----------      
      else {
        fetch('./chords.json?cb=' + Date.now(), { cache: 'no-store' })
          .then(r => {
            if (!r.ok) throw new Error(r.status);
            return r.json();
          })
          .then(db => {
            chordsInput.forEach(ch => {
              const entry = (db[ch] || [{}])[0];
              if (!entry.positions) {
                container.innerHTML += `<p>No existe ${ch}</p>`;
                return;
              }
              // 1) generar SVG de guitarra
              const pos = entry.positions.join(""); // e.g. "320003"
              const fing = entry.fingerings[0].join("");
              const w = document.getElementById("guitarWidth").value;
              const h = document.getElementById("guitarHeight").value;
              const c1 = document.getElementById("whiteKeyColorPicker").value;
              const c2 = document.getElementById("blackKeyColorPicker").value;
              const c3 = document.getElementById("highlightColorPicker").value;

              const svgNode = GenerateGuitarChordSVG(
                ch, pos, fing,
                entry.size || "7", "1", "",
                c1, c2, c3, w, h
              );
              const chordKey = safeFileName(ch);
              svgNode.setAttribute("data-chord-name", chordKey);
              // 2) armar secuencia MIDI de frecuencias (cuerdas no “x”)
              const seq = [];
              for (let i = 0; i < pos.length; i++) {
                const p = pos[i].toLowerCase();
                if (p === "x" || p === "-") continue; // cuerda muteada: no suena
                const fret = parseInt(p) || 0; // “0” = al aire
                const base = stringFreqs[i];
                const freq = base * Math.pow(2, fret / 12);
                seq.push(freq * octaveMultiplier);
              }
              // 3) almacenar y mostrar SVG + botón play
              midiData[chordKey] = seq;
              container.appendChild(svgNode);
              const btn = document.createElement("span");
              btn.className = "play-btn";
              btn.innerText = "▷";
              btn.onclick = () => playSequence(chordKey);
              container.appendChild(btn);
              container.appendChild(document.createElement("br"));
              container.appendChild(document.createElement("br"));
            });
            updateDownloadButton();
          })
          .catch(e => {
            console.error(e);
            container.innerHTML = "<p>Error al leer chords.json</p>";
            updateDownloadButton();
          });
      }
    }

    // ---------- REPRODUCIR SECUENCIA MIDI (Web Audio) ----------
    function playSequence(chordKey) {
      const seq = midiData[chordKey];
      if (!seq || !seq.length) return;
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      let t = ctx.currentTime;
      const dura = 0.5; // 0.5s por nota individual
      // 1) tocar cada frecuencia de a una
      seq.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = "sine";
        const gain = ctx.createGain();
        gain.gain.value = 0.2;
        osc.frequency.value = freq;
        osc.connect(gain).connect(ctx.destination);
        osc.start(t + i * dura);
        osc.stop(t + i * dura + dura * 0.9);
      });
      // 2) al final, tocar todas juntas más rápido (0.1s cada una)
      const offset = seq.length * dura + 0.2;
      seq.forEach((freq, i) => {
        const osc2 = ctx.createOscillator();
        osc2.type = "sine";
        const gain2 = ctx.createGain();
        gain2.gain.value = 0.2;
        osc2.frequency.value = freq;
        osc2.connect(gain2).connect(ctx.destination);
        osc2.start(t + offset + i * 0.1);
        osc2.stop(t + offset + i * 0.1 + 0.09);
      });
    }

    // Convierte nota+octava en Hz (A4=440Hz; MIDI note calc)
    function noteObjToFreq(note, octave) {
      const sem = noteToSemitone[normalizeNote(note)];
      const midiNum = sem + octave * 12;
      // MIDI note A4 = 69, pero si contamos C0=0: A4 = 12*4 + 9 = 57. Ajustamos
      const adj = midiNum - 57;
      return 440 * Math.pow(2, adj / 12);
    }

    function normalizeNote(note) {
      if (note.includes("/")) {
        return note.split("/").map(part => normalizeNote(part)).join("/");
      }
      note = note.trim();
      const fixedCorrections = { "Fb": "E", "E#": "F", "Cb": "B", "B#": "C" };
      if (fixedCorrections[note]) return fixedCorrections[note];
      const regex = /^([A-G])([b#]+)?$/;
      const match = note.match(regex);
      if (match) {
        const naturalSemitones = { "C": 0, "D": 2, "E": 4, "F": 5, "G": 7, "A": 9, "B": 11 };
        const semitoneToSharp = { 0: "C", 1: "C#", 2: "D", 3: "D#", 4: "E", 5: "F", 6: "F#", 7: "G", 8: "G#", 9: "A", 10: "A#", 11: "B" };
        let base = match[1].toUpperCase();
        let accidentals = match[2] || "";
        let semitone = naturalSemitones[base];
        for (let char of accidentals) {
          if (char === "#") { semitone++; }
          else if (char === "b") { semitone--; }
        }
        semitone = (semitone % 12 + 12) % 12;
        return semitoneToSharp[semitone];
      }
      return note;
    }

    // ---------- DESCARGAR SVGs + JSON ----------
    function downloadAll() {
      const svgs = document.querySelectorAll("#svgContainer svg");
      if (!svgs.length) return;
      const zip = new JSZip();
      // 1) agregar todos los SVG
      svgs.forEach((svg, i) => {
        const name = safeFileName(svg.getAttribute("data-chord-name") || `acorde_${i + 1}`);
        const xml = new XMLSerializer().serializeToString(svg);
        zip.file(name + ".svg", xml);
      });
      // 2) armar JSON de midiData
      const jsonStr = JSON.stringify(midiData, null, 2);
      zip.file("acordes.json", jsonStr);
      zip.generateAsync({ type: "blob" }).then(blob => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "acordes_y_midi.zip";
        a.click();
      });
    }

    function updateDownloadButton() {
      const btn = document.getElementById("downloadBtn");
      btn.style.display = document.querySelector("#svgContainer svg") ? "block" : "none";
    }

    function safeFileName(str) {
      return str.trim().replace(/[\/\\]/g, '-').replace(/\s+/g, '');
    }

    // ---------- TOGGLE VISUALIZACIÓN ----------
    function toggleTheme() {
      const body = document.body;
      const themeToggle = document.getElementById("themeToggle");
      if (body.classList.contains("dark-mode")) {
        body.classList.remove("dark-mode");
        body.classList.add("light-mode");
        themeToggle.innerHTML = '<span class="material-icons">dark_mode</span>';
      } else {
        body.classList.remove("light-mode");
        body.classList.add("dark-mode");
        themeToggle.innerHTML = '<span class="material-icons">light_mode</span>';
      }
    }
    function toggleOctaveNumbers() { showOctaveNumbers = !showOctaveNumbers; if (document.getElementById("chordInput").value.trim() !== "") { generateChords(); } }
    function toggleNoteNames() { showNoteNames = !showNoteNames; if (document.getElementById("chordInput").value.trim() !== "") { generateChords(); } }
    function toggleChordName() { showChordName = !showChordName; if (document.getElementById("chordInput").value.trim() !== "") { generateChords(); } }

    // ---------- FUNCIONES DE PIANO (iguales que antes) ----------
    function parseChordSymbol(chordSymbol) {
      chordSymbol = chordSymbol.trim();
      let parts = chordSymbol.split("/");
      let inversion = parts[1] ? parts[1].trim() : null;
      const baseSymbol = parts[0].trim();
      const regex = /^([A-G])((?:#|b)?)(.*)$/;
      const match = baseSymbol.match(regex);
      if (!match) return null;
      let root = match[1] + match[2];
      let type = match[3].trim();
      if (type === "") type = "";
      return {
        root: normalizeNote(root),
        type,
        inversion: inversion ? normalizeNote(inversion) : null
      };
    }

    function getInversionIntervals(intervals, inversionIndex) {
      const n = intervals.length;
      let newIntervals = [];
      for (let i = inversionIndex; i < n; i++) {
        newIntervals.push(intervals[i] - intervals[inversionIndex]);
      }
      for (let i = 0; i < inversionIndex; i++) {
        newIntervals.push(intervals[i] - intervals[inversionIndex] + 12);
      }
      return newIntervals;
    }

    function intervalsToBinary(intervals) {
      let binaryArr = new Array(18).fill("0");
      intervals.forEach(interval => { if (interval < 18) binaryArr[interval] = "1"; });
      return binaryArr.join("");
    }

    function chordToBinary(chordSymbol) {
      const parsed = parseChordSymbol(chordSymbol);
      if (!parsed) return { error: "Símbolo de acorde no válido." };
      const { root, type, inversion } = parsed;
      if (!(type in chordFormulas)) {
        return { error: "Tipo de acorde no soportado: " + type };
      }
      const baseIntervals = chordFormulas[type];
      const baseOctave = 4;
      const rootValue = noteToSemitone[root];
      if (!inversion) {
        const n = baseIntervals.length;
        let best = null;
        for (let inv = 0; inv < n; inv++) {
          const invIntervals = getInversionIntervals(baseIntervals, inv);
          const maxInterval = Math.max(...invIntervals);
          if (maxInterval < 18) { best = { inversion: inv, intervals: invIntervals, maxInterval }; break; }
          if (!best || maxInterval < best.maxInterval) { best = { inversion: inv, intervals: invIntervals, maxInterval }; }
        }
        const p1Value = (rootValue + baseIntervals[best.inversion]) % 12;
        const p1 = semitoneNames[p1Value];
        return { p1, binary: intervalsToBinary(best.intervals), inversion: best.inversion, slash: false };
      } else {
        const bassValue = noteToSemitone[inversion] % 12;
        const chordTones = baseIntervals.map(interval => (rootValue + interval) % 12);
        if (chordTones.includes(bassValue)) {
          let invIndex = chordTones.indexOf(bassValue);
          const invIntervals = getInversionIntervals(baseIntervals, invIndex);
          const p1Value = (rootValue + baseIntervals[invIndex]) % 12;
          const p1 = semitoneNames[p1Value];
          return { p1, binary: intervalsToBinary(invIntervals), inversion: invIndex, slash: true };
        } else {
          const rootAbs = rootValue + baseOctave * 12;
          let chordTonesAbs = baseIntervals.map(interval => rootAbs + interval);
          const bassAbs = noteToSemitone[inversion] + baseOctave * 12;
          chordTonesAbs = chordTonesAbs.map(tone => {
            while (tone < bassAbs) { tone += 12; }
            return tone;
          });
          let finalTones = [bassAbs].concat(chordTonesAbs);
          finalTones.sort((a, b) => a - b);
          let newIntervals = finalTones.map(tone => tone - bassAbs);
          return { p1: inversion, binary: intervalsToBinary(newIntervals), inversion: 0, slash: true };
        }
      }
    }

    function parseChordBinary(chordStr) {
      chordStr = chordStr.trim();
      if (!chordStr) { alert("Por favor, ingresa un acorde."); return null; }
      let result = chordToBinary(chordStr);
      if (result.error) { alert(result.error); return null; }
      let baseOctave = 4;
      let baseSemitone = noteToSemitone[result.p1] + baseOctave * 12;
      let chordNotes = [];
      for (let i = 0; i < result.binary.length; i++) {
        if (result.binary[i] === "1") {
          let noteValue = baseSemitone + i;
          let noteName = semitoneNames[noteValue % 12];
          let octave = Math.floor(noteValue / 12);
          chordNotes.push({ note: noteName, octave: octave });
        }
      }
      return {
        chordNotes: chordNotes,
        label: chordStr,
        p1: result.p1,
        binary: result.binary,
        inversion: (result.inversion !== undefined) ? result.inversion : null,
        slash: result.slash,
        root: parseChordSymbol(chordStr).root
      };
    }

    function generateKeyboardSVG(chordData) {
      let whiteHex = document.getElementById("whiteKeyColorPicker").value;
      let whiteAlpha = document.getElementById("whiteAlpha").value / 100;
      let blackHex = document.getElementById("blackKeyColorPicker").value;
      let blackAlpha = document.getElementById("blackAlpha").value / 100;
      let highlightHex = document.getElementById("highlightColorPicker").value;
      let highlightAlpha = document.getElementById("highlightAlpha").value / 100;
      let whiteNormalColor = getRgba(whiteHex, whiteAlpha);
      let blackNormalColor = getRgba(blackHex, blackAlpha);
      let highlightColor = getRgba(highlightHex, highlightAlpha);
      const whiteKeyWidth = 50,
        whiteKeyHeight = 200,
        blackKeyWidth = 30,
        blackKeyHeight = 120,
        marginTop = 30;
      const whiteOrder = ["C", "D", "E", "F", "G", "A", "B"];
      let virtualWhiteKeys = [];
      for (let octave = 3; octave <= 5; octave++) {
        for (let i = 0; i < whiteOrder.length; i++) {
          virtualWhiteKeys.push({ note: whiteOrder[i], octave: octave, x: virtualWhiteKeys.length * whiteKeyWidth });
        }
      }
      const totalWhiteKeys = virtualWhiteKeys.length;
      const containerWhiteKeys = 10;
      const containerWidth = containerWhiteKeys * whiteKeyWidth;
      const svgHeight = marginTop + whiteKeyHeight + 20;
      let indices = [];
      chordData.chordNotes.forEach(ch => {
        if (!ch.note.includes("#")) {
          let idx = whiteOrder.indexOf(ch.note);
          if (idx !== -1) { indices.push((ch.octave - 3) * 7 + idx); }
        } else {
          let idx = whiteOrder.indexOf(ch.note[0]);
          if (idx !== -1) { indices.push((ch.octave - 3) * 7 + idx + 0.5); }
        }
      });
      let centerIndex = indices.length ? (Math.min(...indices) + Math.max(...indices)) / 2 : totalWhiteKeys / 2;
      let startIndex = Math.round(centerIndex - containerWhiteKeys / 2);
      if (startIndex < 0) startIndex = 0;
      if (startIndex > totalWhiteKeys - containerWhiteKeys) startIndex = totalWhiteKeys - containerWhiteKeys;
      let viewBoxX = startIndex * whiteKeyWidth;
      let svg = `<svg width="80%" viewBox="${viewBoxX} 0 ${containerWidth} ${svgHeight}" xmlns="http://www.w3.org/2000/svg" style="display:block; margin: 0 auto;">`;
      if (showChordName) {
        svg += `<text x="${viewBoxX + containerWidth / 2}" y="20" text-anchor="middle" font-size="18" fill="black">
          ${formatChordLabel(chordData.label)}
        </text>`;
      }
      virtualWhiteKeys.forEach((key) => {
        let highlight = chordData.chordNotes.some(ch => (!ch.note.includes("#") && key.note === ch.note && key.octave === ch.octave));
        let fillColor = highlight ? highlightColor : whiteNormalColor;
        svg += `<rect x="${key.x}" y="${marginTop}" width="${whiteKeyWidth}" height="${whiteKeyHeight}"
          fill="${fillColor}" stroke="black" data-normal-fill="${whiteNormalColor}" onclick="toggleKeyColor(event)" ontouchstart="toggleKeyColor(event)" />`;
        if (showNoteNames) {
          let label = key.note;
          if (showOctaveNumbers) { label += key.octave; }
          svg += `<text x="${key.x + whiteKeyWidth / 2}" y="${marginTop + whiteKeyHeight - 10}" text-anchor="middle" font-size="16" fill="black">${label}</text>`;
        }
      });
      virtualWhiteKeys.forEach((key) => {
        if (key.note === "E" || key.note === "B") return;
        if (["C", "D", "F", "G", "A"].includes(key.note)) {
          let x = key.x + whiteKeyWidth - (blackKeyWidth / 2);
          const mapping = { "C": "C#", "D": "D#", "F": "F#", "G": "G#", "A": "A#" };
          let blackNote = mapping[key.note];
          let highlight = chordData.chordNotes.some(ch => ch.note === blackNote && ch.octave === key.octave);
          let fillColor = highlight ? highlightColor : blackNormalColor;
          svg += `<rect x="${x}" y="${marginTop}" width="${blackKeyWidth}" height="${blackKeyHeight}"
            fill="${fillColor}" stroke="black" data-normal-fill="${blackNormalColor}" onclick="toggleKeyColor(event)" ontouchstart="toggleKeyColor(event)" />`;
        }
      });
      svg += `</svg>`;
      return svg;
    }

    function setupKeyboardGhosts() {
      const svgContainer = document.getElementById('svgContainer');

      svgContainer.addEventListener('mousemove', (event) => {
        const target = event.target;
        if (target.tagName === 'rect' && !target.dataset.toggled) {
          clearGhosts();
          target.dataset.originalFill = target.getAttribute('fill');
          target.setAttribute('fill', '#cccccc'); // Color gris para la previsualización
          target.dataset.ghost = "true";
        } else {
          clearGhosts();
        }
      });

      svgContainer.addEventListener('mouseleave', clearGhosts);

      svgContainer.addEventListener('click', (event) => {
        const target = event.target;
        if (target.tagName === 'rect') {
          clearGhosts();
          target.setAttribute('fill', document.getElementById("highlightColorPicker").value);
          target.dataset.toggled = "true";
        }
      });

      function clearGhosts() {
        document.querySelectorAll('[data-ghost="true"]').forEach(key => {
          key.setAttribute('fill', key.dataset.originalFill);
          delete key.dataset.ghost;
        });
      }
    }

    function getRgba(hex, alpha) {
      hex = hex.replace('#', '');
      let bigint = parseInt(hex, 16);
      let r, g, b;
      if (hex.length === 3) {
        r = (bigint >> 8) & 0xF;
        g = (bigint >> 4) & 0xF;
        b = bigint & 0xF;
        r = (r << 4) | r;
        g = (g << 4) | g;
        b = (b << 4) | b;
      } else {
        r = (bigint >> 16) & 255;
        g = (bigint >> 8) & 255;
        b = bigint & 255;
      }
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function toggleKeyColor(evt) {
      evt.preventDefault();
      const key = evt.target.closest('rect');
      if (!key) return;

      const highlight = document.getElementById("highlightColorPicker").value;
      const normal = key.getAttribute("data-normal-fill");

      if (key.hasAttribute("data-toggled")) {
        key.removeAttribute("data-toggled");
        key.setAttribute("fill", normal);
      } else {
        key.setAttribute("data-toggled", "");
        key.setAttribute("fill", highlight);
      }
    }

    function formatChordLabel(chord) {
      if (!chord || chord.length === 0) return chord;
      return chord.charAt(0).toUpperCase() + chord.slice(1);
    }
  </script>
</body>

</html>
